# インデックスを設定できる

## 1. インデックス設定前

employees データベースの employees テーブルに対して、誕生日が1961年8月3日のレコードを取得してください。その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測してください。
```sql
EXPLAIN ANALYZE
SELECT
  *
FROM
  employees
WHERE
  birth_date='1961-08-03'
;
```

## 2. インデックスの作成

employees データベースの employees テーブルの birth_date カラムにインデックスを作成してください。
```sql
CREATE INDEX birth_date_index ON employees (birth_date);
```

## 3. インデックスの確認

employees データベースの employees テーブルのインデックスを確認し、インデックスが作成されていることを確認してください。
```sql
SHOW INDEX FROM employees;
```

## 4. インデックスの効果の確認

1と同じクエリを実行してください。その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測し、実行が高速化されていることを確認してください。
```sql
EXPLAIN ANALYZE
SELECT
  *
FROM
  employees
WHERE
  birth_date='1961-08-03'
;
```

## 5. インデックスの説明

インデックスを貼ることでクエリが高速化された理由をデータベース初心者にわかるように説明してください。
```
・データベースのインデックスとは、本の索引と似た概念であり、データベース内のテーブルで特定の行を素早く検索する手助けをします。
・インデックスが適切に作成されていると、データベースはフルテーブルスキャンせずに、特定のキーに基づいて迅速にデータを検索でき、クエリの実行速度が向上します。
・ただし、インデックスは全てのカラムに作成するわけではなく、最適化されたクエリの実行をサポートするために、適切に選択する必要があります。
```

## 6. インデックスの削除

作成したインデックスを削除してください。
```sql
DROP INDEX birth_date_index ON employees;
```

## 7. ベストプラクティス

インデックスは作成すればするほどよいというものではありません。必要な場合のみ作成することが重要です。

インデックス作成のベストプラクティスについて調べ、どのような方針でインデックスを貼ると良いかまとめてください。
```
①クエリが決まってから高速化するためにインデックスを設計する。
・インデックスは高速化されるだけで、クエリの結果が変わるわけではない
・不必要なカラムには作成する必要がない。
・SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する。

②大規模なテーブルに対して作成する。
・データ量が少ない（１万レコード以下）と効果がない。

③カーディナリティの高い（列の値の種類が多い）列に作成する。
・列の値の種類が少ないと絞り込めない。（全体のレコードの５％以下に絞り込める。）

④インデックスが効かないSQLの記述方法がある。
・インデックス列に演算を行う（WHERE id*2 > 10）
  →（WHERE id > 10/2）ならOK
・IS NULL術後を使っている（WHERE is IS NULL）
・否定形を使っている（WHERE id <> 10）
・ORを使っている（WHERE id = 10 OR id = 11）
  →id IN (10,11)ならOK
・後方一致、中間一致のLIKE術後を使っている（WHERE name LIKE '%a'）

⑤プライマリーキー及びユニークキーの列には作成しなくていい

⑥無駄なインデックスは極力作成しない
・インデックスの列の値が変更されると、インデックスを作成し直さないといけないので、インデックスの作成に時間がかかる。
・B＋treeインデックスは更新性能を悪化する。
```
